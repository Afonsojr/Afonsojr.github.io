<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Color Logic: Sequence Breaker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');
    
    :root {
      --bg: #050508;
      --panel: #0a0a12;
      --panel-light: #12121a;
      --text: #ffffff;
      --muted: #6b7280;
      --accent: #00d9ff;
      --accent-glow: rgba(0, 217, 255, 0.5);
      
      --neon-blue: #00d9ff;
      --neon-purple: #b829dd;
      --neon-amber: #ffaa00;
      --neon-emerald: #00ff88;
      --neon-crimson: #ff3366;
      --neon-pink: #ff00aa;
      --neon-cyan: #00ffff;
      --neon-lime: #aaff00;
      
      --danger: #ff3366;
      --success: #00ff88;
      --warning: #ffaa00;
    }

    * {
      box-sizing: border-box;
      font-family: 'Rajdhani', system-ui, sans-serif;
      user-select: none;
    }

    body {
      margin: 0;
      background: 
        radial-gradient(ellipse at 20% 80%, rgba(0, 217, 255, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 20%, rgba(184, 41, 221, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, #0a0a15 0%, #000000 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    /* Part√≠culas de fundo */
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }

    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: var(--accent);
      border-radius: 50%;
      opacity: 0.3;
      animation: float 15s infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
      10% { opacity: 0.3; }
      90% { opacity: 0.3; }
      100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
    }

    .game {
      position: relative;
      z-index: 1;
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 24px;
      width: min(1200px, 95%);
    }

    /* ===================== MAIN PANEL ===================== */

    .main {
      background: linear-gradient(135deg, rgba(10,10,18,0.95), rgba(18,18,26,0.95));
      border-radius: 24px;
      padding: 32px;
      border: 1px solid rgba(0, 217, 255, 0.2);
      box-shadow: 
        0 0 60px rgba(0, 217, 255, 0.1),
        inset 0 1px 0 rgba(255,255,255,0.05);
      backdrop-filter: blur(10px);
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }

    h1 {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8rem;
      font-weight: 900;
      background: linear-gradient(135deg, #fff, var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 30px var(--accent-glow);
    }

    /* Bot√£o de Ajuda */
    .help-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0,217,255,0.2), rgba(184,41,221,0.2));
      border: 2px solid rgba(0,217,255,0.5);
      color: var(--accent);
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      box-shadow: 0 0 15px rgba(0,217,255,0.3);
    }

    .help-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 25px var(--accent-glow);
      border-color: var(--accent);
    }

    /* Vidas */
    .lives-container {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .heart {
      font-size: 1.5rem;
      filter: drop-shadow(0 0 8px rgba(255, 51, 102, 0.8));
      transition: all 0.3s ease;
    }

    .heart.lost {
      opacity: 0.2;
      filter: grayscale(100%);
    }

    .heart.broken {
      animation: heart-break 0.6s ease forwards;
    }

    @keyframes heart-break {
      0% { transform: scale(1); }
      50% { transform: scale(1.4); filter: drop-shadow(0 0 20px var(--danger)); }
      100% { transform: scale(0); opacity: 0; }
    }

    /* Barra de Progresso */
    .progress-container {
      margin-bottom: 20px;
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .progress-bar {
      height: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--neon-purple), var(--accent));
      border-radius: 4px;
      transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 0 20px var(--accent-glow);
      position: relative;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: progress-shine 2s infinite;
    }

    @keyframes progress-shine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* Status Grid */
    .status-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: linear-gradient(135deg, rgba(0,217,255,0.1), rgba(184,41,221,0.1));
      border: 1px solid rgba(0,217,255,0.2);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transition: left 0.5s;
    }

    .stat-card:hover::before {
      left: 100%;
    }

    .stat-label {
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }

    .stat-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 0 10px var(--accent-glow);
    }

    .stat-value.combo {
      color: var(--neon-amber);
      text-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
      animation: combo-pulse 0.5s ease;
    }

    @keyframes combo-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    /* Mensagem Motivacional */
    .motivational-msg {
      text-align: center;
      padding: 12px;
      margin-bottom: 16px;
      font-size: 1.1rem;
      font-weight: 700;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
    }

    .motivational-msg.excellent {
      color: var(--neon-emerald);
      text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
      animation: msg-pop 0.5s ease;
    }

    .motivational-msg.good {
      color: var(--accent);
      text-shadow: 0 0 15px var(--accent-glow);
    }

    .motivational-msg.warning {
      color: var(--warning);
      animation: shake 0.5s ease;
    }

    @keyframes msg-pop {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    @keyframes fade-in-out {
      0% { opacity: 0; transform: translateY(20px); }
      15% { opacity: 1; transform: translateY(0); }
      85% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-20px); }
    }

    @keyframes pulse-hint {
      from { transform: scale(1); }
      to { transform: scale(1.08); }
    }

    /* Board Geom√©trico */
    .board {
      position: relative;
      width: 100%;
      height: 350px;
      margin: 24px 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .shape-container {
      position: relative;
      width: 300px;
      height: 300px;
      transition: all 0.5s ease;
    }

    .slot-wrapper {
      position: absolute;
      width: 70px;
      height: 70px;
      transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    /* Conectores entre blocos */
    .connector {
      position: absolute;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), var(--neon-purple));
      transform-origin: left center;
      opacity: 0.4;
      z-index: 0;
      transition: all 0.5s ease;
    }

    .connector.active {
      opacity: 0.8;
      box-shadow: 0 0 10px var(--accent-glow);
    }

    .slot {
      width: 70px;
      height: 70px;
      border-radius: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      position: relative;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 
        0 4px 20px rgba(0,0,0,0.4),
        inset 0 2px 4px rgba(255,255,255,0.1),
        inset 0 -2px 4px rgba(0,0,0,0.2);
      will-change: transform;
    }

    .slot-wrapper .slot {
      width: 100%;
      height: 100%;
    }

    .slot::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 16px;
      padding: 2px;
      background: linear-gradient(135deg, rgba(255,255,255,0.3), transparent);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
    }

    .slot:hover {
      transform: translateY(-6px) scale(1.05);
      box-shadow: 
        0 12px 30px rgba(0,0,0,0.5),
        0 0 30px var(--accent-glow);
    }

    .slot.selected {
      box-shadow:
        0 0 0 3px #fff,
        0 0 0 6px var(--accent),
        0 0 40px var(--accent-glow);
      transform: scale(1.12);
      z-index: 10;
      animation: pulse-select 0.6s ease-in-out infinite alternate;
    }

    @keyframes pulse-select {
      from { transform: scale(1.12); }
      to { transform: scale(1.18); }
    }

    .slot.correct {
      box-shadow:
        0 0 0 3px var(--success),
        0 0 30px rgba(0, 255, 136, 0.6);
      animation: correct-pulse 0.5s ease;
    }

    .slot.wrong {
      animation: wrong-shake 0.5s ease;
      box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
    }

    @keyframes correct-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }

    @keyframes wrong-shake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-10px) rotate(-5deg); }
      40% { transform: translateX(10px) rotate(5deg); }
      60% { transform: translateX(-10px) rotate(-5deg); }
      80% { transform: translateX(10px) rotate(5deg); }
    }

    .slot.animating {
      z-index: 100;
      pointer-events: none;
    }

    /* Acessibilidade - S√≠mbolos vis√≠veis */
    .slot {
      border: 3px solid transparent;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.2s ease;
    }

    .slot[data-color="blue"] { border-color: #0066CC; }
    .slot[data-color="purple"] { border-color: #9933CC; }
    .slot[data-color="amber"] { border-color: #CC9900; }
    .slot[data-color="emerald"] { border-color: #00CC66; }
    .slot[data-color="crimson"] { border-color: #CC0033; }
    .slot[data-color="pink"] { border-color: #CC0066; }
    .slot[data-color="cyan"] { border-color: #00CCCC; }
    .slot[data-color="lime"] { border-color: #99CC00; }

    .slot.selected {
      border-color: #fff !important;
      box-shadow:
        0 0 0 3px #fff,
        0 0 0 6px var(--accent),
        0 0 40px var(--accent-glow);
    }

    .slot.correct {
      border-color: var(--success) !important;
      box-shadow:
        0 0 0 3px var(--success),
        0 0 30px rgba(0, 255, 136, 0.6);
    }

    /* Part√≠culas de efeito */
    .particle-effect {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 1000;
    }

    /* Controles */
    .controls {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 20px;
    }

    button {
      background: linear-gradient(135deg, var(--neon-purple), var(--accent));
      border: none;
      color: #fff;
      padding: 14px 28px;
      border-radius: 12px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 30px var(--accent-glow);
    }

    button:hover::before {
      left: 100%;
    }

    button:active {
      transform: translateY(-1px);
    }

    button.secondary {
      background: transparent;
      border: 2px solid rgba(255,255,255,0.2);
    }

    button.secondary:hover {
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(0,217,255,0.3);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* ===================== SIDE PANEL ===================== */

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .panel-section {
      background: linear-gradient(135deg, rgba(10,10,18,0.95), rgba(18,18,26,0.95));
      border-radius: 20px;
      padding: 20px;
      border: 1px solid rgba(0, 217, 255, 0.15);
      box-shadow: 0 4px 30px rgba(0,0,0,0.3);
    }

    .panel-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      color: var(--accent);
      margin: 0 0 16px 0;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Estrelas de Performance */
    .stars-container {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .star {
      font-size: 2rem;
      opacity: 0.2;
      filter: grayscale(100%);
      transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .star.earned {
      opacity: 1;
      filter: grayscale(0%) drop-shadow(0 0 15px rgba(255, 170, 0, 0.8));
      animation: star-pop 0.6s ease;
    }

    @keyframes star-pop {
      0% { transform: scale(0) rotate(-180deg); }
      70% { transform: scale(1.3) rotate(20deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    .performance-text {
      text-align: center;
      font-size: 0.9rem;
      color: var(--muted);
    }

    /* Hist√≥rico */
    .log {
      max-height: 300px;
      overflow-y: auto;
    }

    .log-entry {
      font-size: 0.85rem;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.03);
      margin-bottom: 8px;
      border-left: 3px solid var(--accent);
      display: flex;
      justify-content: space-between;
      align-items: center;
      animation: slide-in 0.3s ease;
    }

    @keyframes slide-in {
      from { transform: translateX(-20px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .log-entry.perfect {
      border-left-color: var(--success);
      background: rgba(0, 255, 136, 0.05);
    }

    .log-entry.bad {
      border-left-color: var(--danger);
    }

    /* ===================== RULES MODAL ===================== */

    .rules-container {
      background: linear-gradient(135deg, rgba(10,10,18,0.98), rgba(18,18,26,0.98));
      border-radius: 24px;
      padding: 32px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      border: 2px solid rgba(0, 217, 255, 0.3);
      box-shadow: 0 0 60px rgba(0, 217, 255, 0.2);
      animation: rules-appear 0.5s ease;
    }

    @keyframes rules-appear {
      0% { transform: scale(0.8) translateY(-50px); opacity: 0; }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }

    .rules-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .rules-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--accent);
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 20px var(--accent-glow);
    }

    .close-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 51, 102, 0.2);
      border: 2px solid var(--danger);
      color: var(--danger);
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .close-btn:hover {
      background: var(--danger);
      color: #fff;
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
    }

    .rules-content {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .rule-item {
      display: flex;
      align-items: flex-start;
      gap: 16px;
      padding: 16px;
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.05);
      transition: all 0.3s ease;
    }

    .rule-item:hover {
      background: rgba(0, 217, 255, 0.05);
      border-color: rgba(0, 217, 255, 0.2);
      transform: translateX(5px);
    }

    .rule-icon {
      font-size: 1.8rem;
      flex-shrink: 0;
    }

    .rule-text {
      font-size: 1rem;
      line-height: 1.5;
      color: var(--text);
    }

    .rule-text strong {
      color: var(--accent);
      font-family: 'Orbitron', sans-serif;
    }

    .rules-footer {
      margin-top: 24px;
      text-align: center;
    }

    .rules-btn {
      background: linear-gradient(135deg, var(--neon-purple), var(--accent));
      border: none;
      color: #fff;
      padding: 16px 32px;
      border-radius: 12px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 1.1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .rules-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 30px var(--accent-glow);
    }

    /* ===================== OVERLAYS ===================== */

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.92);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
      backdrop-filter: blur(10px);
    }

    .overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .victory-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 3rem;
      font-weight: 900;
      background: linear-gradient(135deg, var(--accent), var(--neon-purple), var(--neon-amber));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
      margin-bottom: 10px;
      animation: victory-bounce 0.8s ease-out;
      text-transform: uppercase;
      letter-spacing: 4px;
    }

    .victory-subtitle {
      font-size: 1.2rem;
      color: var(--muted);
      margin-bottom: 30px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .stats-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin: 30px 0;
      padding: 20px;
      background: rgba(255,255,255,0.03);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .summary-item {
      text-align: center;
    }

    .summary-value {
      font-family: 'Orbitron', sans-serif;
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent);
    }

    .summary-label {
      font-size: 0.8rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 4px;
    }

    @keyframes victory-bounce {
      0% { transform: scale(0) rotate(-10deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(5deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    .gameover-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.5rem;
      font-weight: 900;
      color: var(--danger);
      text-align: center;
      margin-bottom: 10px;
      animation: gameover-shake 0.6s ease-out;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    @keyframes gameover-shake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-15px); }
      40% { transform: translateX(15px); }
      60% { transform: translateX(-15px); }
      80% { transform: translateX(15px); }
    }

    .solution-container {
      background: rgba(255,255,255,0.03);
      border-radius: 20px;
      padding: 30px;
      margin: 20px 0;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .solution-label {
      text-align: center;
      color: var(--muted);
      font-size: 1.1rem;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .solution-board {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 270px;
    }

    .solution-slot {
      width: 60px;
      height: 60px;
      border-radius: 14px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      animation: solution-pop 0.5s ease-out backwards;
      position: relative;
    }

    .solution-slot::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 14px;
      padding: 2px;
      background: linear-gradient(135deg, rgba(255,255,255,0.4), transparent);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
    }

    @keyframes solution-pop {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; }
      70% { transform: scale(1.15) rotate(10deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    /* Confetti */
    .confetti {
      position: fixed;
      width: 12px;
      height: 12px;
      z-index: 2000;
      pointer-events: none;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .game {
        grid-template-columns: 1fr;
      }
      
      .side-panel {
        flex-direction: row;
        flex-wrap: wrap;
      }
      
      .panel-section {
        flex: 1;
        min-width: 280px;
      }
    }
  </style>
</head>

<body>
  <!-- Part√≠culas de Fundo -->
  <div class="particles" id="particles"></div>

  <!-- Overlays -->
  <div class="overlay" id="victoryOverlay">
    <div class="victory-text">N√çVEL COMPLETADO!</div>
    <div class="victory-subtitle">Voc√™ √© incr√≠vel!</div>
    <div class="stars-container" id="victoryStars">
      <span class="star">‚≠ê</span>
      <span class="star">‚≠ê</span>
      <span class="star">‚≠ê</span>
    </div>
    <div class="stats-summary">
      <div class="summary-item">
        <div class="summary-value" id="summaryScore">0</div>
        <div class="summary-label">Pontua√ß√£o</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryCombo">0</div>
        <div class="summary-label">Combo M√°x</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryAccuracy">0%</div>
        <div class="summary-label">Precis√£o</div>
      </div>
    </div>
    <button onclick="nextLevel()">Pr√≥ximo N√≠vel ‚Üí</button>
  </div>

  <div class="overlay" id="gameoverOverlay">
    <div class="gameover-text">FIM DE JOGO</div>
    <div class="solution-container">
      <div class="solution-label">Sequ√™ncia Correta</div>
      <div class="solution-board" id="solutionBoard"></div>
    </div>
    <button onclick="restartGame()">Tentar Novamente ‚Ü∫</button>
  </div>

  <!-- Rules Modal -->
  <div class="overlay" id="rulesOverlay">
    <div class="rules-container">
      <div class="rules-header">
        <h2 class="rules-title">üìñ COMO JOGAR</h2>
        <button class="close-btn" onclick="hideRules()">‚úï</button>
      </div>
      
      <div class="rules-content">
        <div class="rule-item">
          <div class="rule-icon">üéØ</div>
          <div class="rule-text">
            <strong>Objetivo:</strong> Organize as pe√ßas coloridas na sequ√™ncia correta.
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">üëÜ</div>
          <div class="rule-text">
            <strong>Como jogar:</strong> Clique em duas pe√ßas para troc√°-las de posi√ß√£o.
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">‚úì</div>
          <div class="rule-text">
            <strong>Verificar:</strong> Clique no bot√£o "Verificar" para confirmar sua resposta.
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">‚ù§Ô∏è</div>
          <div class="rule-text">
            <strong>Vidas:</strong> Cada erro remove uma vida. Perdeu todas? Game over!
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">üí°</div>
          <div class="rule-text">
            <strong>Dicas:</strong> Pressione 'D' ou clique em "Dica" para revelar uma posi√ß√£o correta.
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">‚≠ê</div>
          <div class="rule-text">
            <strong>Estrelas:</strong> Complete sem erros para ganhar 3 estrelas!
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">üî•</div>
          <div class="rule-text">
            <strong>Combo:</strong> Acertos consecutivos aumentam seu multiplicador de pontos.
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">üìä</div>
          <div class="rule-text">
            <strong>Dificuldade:</strong> A cada n√≠vel, mais cores e combina√ß√µes s√£o adicionadas.
          </div>
        </div>
      </div>
      
      <div class="rules-footer">
        <button onclick="hideRules()" class="rules-btn">Entendi! Vamos jogar üöÄ</button>
      </div>
    </div>
  </div>

  <!-- Game Interface -->
  <div class="game">
    <div class="main">
      <div class="game-header">
        <h1>Sequence Breaker</h1>
        <div style="display: flex; gap: 12px; align-items: center;">
          <button class="help-btn" id="helpBtn" title="Como Jogar">‚ùì</button>
          <div class="lives-container" id="livesContainer">
            <span class="heart">‚ù§Ô∏è</span>
            <span class="heart">‚ù§Ô∏è</span>
            <span class="heart">‚ù§Ô∏è</span>
          </div>
        </div>
      </div>

      <!-- Barra de Progresso -->
      <div class="progress-container">
        <div class="progress-header">
          <span>Progresso do N√≠vel</span>
          <span id="progressText">0%</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
      </div>

      <!-- Status Grid -->
      <div class="status-grid">
        <div class="stat-card">
          <div class="stat-label">N√≠vel</div>
          <div class="stat-value" id="level">1</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Pontos</div>
          <div class="stat-value" id="score">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Combo</div>
          <div class="stat-value" id="combo">x1</div>
        </div>
      </div>

      <!-- Mensagem Motivacional -->
      <div class="motivational-msg" id="motivationalMsg">
        Clique nas pe√ßas para organizar as cores! Pressione '?' para ver as regras
      </div>

      <!-- Board -->
      <div class="board" id="board"></div>

      <!-- Controles -->
      <div class="controls">
        <button id="checkBtn">‚úì Verificar</button>
        <button id="hintBtn" class="secondary">üí° Dica</button>
        <button id="resetBtn" class="secondary">‚Ü∫ Reiniciar</button>
      </div>
    </div>

    <div class="side-panel">
      <!-- Performance -->
      <div class="panel-section">
        <h3 class="panel-title">üèÜ Performance</h3>
        <div class="stars-container" id="performanceStars">
          <span class="star">‚≠ê</span>
          <span class="star">‚≠ê</span>
          <span class="star">‚≠ê</span>
        </div>
        <div class="performance-text" id="performanceText">
          Complete sem erros para ganhar 3 estrelas!
        </div>
      </div>

      <!-- Estat√≠sticas do N√≠vel -->
      <div class="panel-section">
        <h3 class="panel-title">üìà Estat√≠sticas</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
          <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="color: var(--muted); font-size: 0.75rem;">Combina√ß√µes</div>
            <div style="font-family: 'Orbitron', sans-serif; font-weight: 700; color: var(--accent);" id="statCombinations">6</div>
          </div>
          <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="color: var(--muted); font-size: 0.75rem;">Vidas</div>
            <div style="font-family: 'Orbitron', sans-serif; font-weight: 700; color: var(--success);" id="statLives">3</div>
          </div>
          <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="color: var(--muted); font-size: 0.75rem;">Dicas</div>
            <div style="font-family: 'Orbitron', sans-serif; font-weight: 700; color: var(--warning);" id="hintsDisplay">1</div>
          </div>
          <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="color: var(--muted); font-size: 0.75rem;">Chance</div>
            <div style="font-family: 'Orbitron', sans-serif; font-weight: 700; color: var(--neon-purple);" id="statChance">50%</div>
          </div>
        </div>
        <div style="font-size: 0.8rem; color: var(--muted); text-align: center; margin-top: 10px;">
          Pressione 'D' para usar dica
        </div>
      </div>

      <!-- Hist√≥rico -->
      <div class="panel-section">
        <h3 class="panel-title">üìä Hist√≥rico</h3>
        <div class="log" id="log"></div>
      </div>

      <!-- Estat√≠sticas Salvas -->
      <div class="panel-section">
        <h3 class="panel-title">üèÜ Seu Progresso</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
          <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="color: var(--muted); font-size: 0.75rem;">Maior Score</div>
            <div style="font-family: 'Orbitron', sans-serif; font-weight: 700; color: var(--neon-amber);" id="highScoreDisplay">0</div>
          </div>
          <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="color: var(--muted); font-size: 0.75rem;">Jogos</div>
            <div style="font-family: 'Orbitron', sans-serif; font-weight: 700; color: var(--accent);" id="gamesPlayedDisplay">0</div>
          </div>
          <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 8px; grid-column: span 2;">
            <div style="color: var(--muted); font-size: 0.75rem;">√öltimo Jogo</div>
            <div style="font-family: 'Rajdhani', sans-serif; font-size: 0.8rem; color: var(--muted); margin-top: 4px;" id="lastPlayedDisplay">-</div>
          </div>
        </div>
        <button onclick="resetProgress()" class="secondary" style="width: 100%; margin-top: 12px; padding: 10px; font-size: 0.85rem;">
          üóëÔ∏è Resetar Progresso
        </button>
      </div>
    </div>
  </div>

  <script>
    const COLORS = [
      { name: "Blue", value: "var(--neon-blue)", symbol: "‚óÜ", pattern: "linear-gradient(135deg, transparent 25%, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.1) 50%, transparent 50%)" },
      { name: "Purple", value: "var(--neon-purple)", symbol: "‚óè", pattern: "radial-gradient(circle at 30% 30%, rgba(255,255,255,0.15) 0%, transparent 50%)" },
      { name: "Amber", value: "var(--neon-amber)", symbol: "‚ñ≤", pattern: "linear-gradient(45deg, transparent 40%, rgba(0,0,0,0.2) 40%, rgba(0,0,0,0.2) 60%, transparent 60%)" },
      { name: "Emerald", value: "var(--neon-emerald)", symbol: "‚ñ†", pattern: "repeating-linear-gradient(90deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px)" },
      { name: "Crimson", value: "var(--neon-crimson)", symbol: "‚òÖ", pattern: "radial-gradient(circle at 70% 70%, rgba(255,255,255,0.1) 0%, transparent 40%)" },
      { name: "Pink", value: "var(--neon-pink)", symbol: "‚ô¶", pattern: "linear-gradient(135deg, rgba(0,0,0,0.1) 25%, transparent 25%, transparent 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1) 75%, transparent 75%)" },
      { name: "Cyan", value: "var(--neon-cyan)", symbol: "‚óã", pattern: "repeating-radial-gradient(circle at 50% 50%, transparent 0, transparent 5px, rgba(0,0,0,0.1) 5px, rgba(0,0,0,0.1) 10px)" },
      { name: "Lime", value: "var(--neon-lime)", symbol: "‚ñ°", pattern: "linear-gradient(0deg, transparent 50%, rgba(0,0,0,0.1) 50%)" },
    ];

    const MESSAGES = {
      start: ["Organize as cores!", "Vamos come√ßar!", "Mostre sua habilidade!"],
      first: ["Primeira pe√ßa!", "Boa escolha!", "Continue!"],
      swap: ["Troca perfeita!", "√ìtimo movimento!", "Isso a√≠!"],
      excellent: ["INCR√çVEL!", "PERFEITO!", "GENIAL!", "FANT√ÅSTICO!"],
      good: ["Muito bem!", "Bom trabalho!", "Continue assim!"],
      okay: ["Quase l√°!", "Voc√™ consegue!", "Mais uma tentativa!"],
      bad: ["N√£o desista!", "Tente novamente!", "Foque!"],
      danger: ["Cuidado!", "Poucas vidas!", "Se concentre!"]
    };

    // Matem√°tica do jogo - C√°lculo de probabilidades
    function factorial(n) {
      if (n <= 1) return 1;
      return n * factorial(n - 1);
    }

    // Calcula vidas baseado no n√∫mero de permuta√ß√µes poss√≠veis
    // Quanto mais permuta√ß√µes, mais vidas necess√°rias
    function calculateLives(numSlots) {
      const permutations = factorial(numSlots);
      // F√≥rmula: raiz quadrada do fatorial dividido por 2, arredondado para cima
      // Isso d√° chances razo√°veis sem ser imposs√≠vel
      let lives = Math.ceil(Math.sqrt(permutations) / 2);
      
      // Ajuste por n√≠vel (n√≠veis mais altos = menos vidas relativas)
      lives = Math.max(3, Math.min(lives, 15)); // M√≠nimo 3, m√°ximo 15
      
      return lives;
    }

    // Revelar dicas progressivamente
    function getHints(level, numSlots) {
      // A cada 3 n√≠veis, ganha uma dica extra
      return Math.floor((level - 1) / 3) + 1;
    }

    let level = 1;
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let lives = 3;
    let maxLives = 3;
    let secret = [];
    let boardState = [];
    let selected = [];
    let attempts = [];
    let logRound = 1;
    let gameActive = true;
    let hintsUsed = 0;
    let revealedPositions = new Set(); // Posi√ß√µes j√° reveladas como dicas
    let highScore = 0;
    let gamesPlayed = 0;
    let isSwapping = false; // Flag para evitar trocas durante anima√ß√£o

    // Carregar dados salvos
    function loadGame() {
      const saved = localStorage.getItem('sequenceBreaker');
      if (saved) {
        const data = JSON.parse(saved);
        level = data.level || 1;
        score = data.score || 0;
        maxCombo = data.maxCombo || 0;
        highScore = data.highScore || 0;
        gamesPlayed = data.gamesPlayed || 0;
        console.log('Jogo carregado:', data);
      }
    }

    // Salvar progresso
    function saveGame() {
      const data = {
        level,
        score,
        maxCombo,
        highScore: Math.max(highScore, score),
        gamesPlayed,
        lastPlayed: new Date().toISOString()
      };
      localStorage.setItem('sequenceBreaker', JSON.stringify(data));
      
      // Feedback visual sutil
      showSaveIndicator();
    }

    // Indicador visual de salvamento
    function showSaveIndicator() {
      const indicator = document.createElement('div');
      indicator.textContent = 'üíæ Salvo!';
      indicator.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 255, 136, 0.9);
        color: #000;
        padding: 8px 16px;
        border-radius: 8px;
        font-family: 'Orbitron', sans-serif;
        font-size: 0.8rem;
        font-weight: 700;
        z-index: 9999;
        animation: fade-in-out 2s ease forwards;
      `;
      document.body.appendChild(indicator);
      setTimeout(() => indicator.remove(), 2000);
    }

    // Resetar progresso
    function resetProgress() {
      if (confirm('Tem certeza que deseja apagar todo o progresso?')) {
        localStorage.removeItem('sequenceBreaker');
        // Marca que foi feito um reset para n√£o carregar dados antigos
        localStorage.setItem('sequenceBreaker_reset', Date.now().toString());
        level = 1;
        score = 0;
        maxCombo = 0;
        gamesPlayed = 0;
        highScore = 0;
        startLevel();
        alert('Progresso resetado com sucesso!');
      }
    }

    const boardEl = document.getElementById("board");
    const levelEl = document.getElementById("level");
    const scoreEl = document.getElementById("score");
    const comboEl = document.getElementById("combo");
    const livesContainer = document.getElementById("livesContainer");
    const progressFill = document.getElementById("progressFill");
    const progressText = document.getElementById("progressText");
    const msgEl = document.getElementById("motivationalMsg");
    const performanceStars = document.getElementById("performanceStars");
    const performanceText = document.getElementById("performanceText");
    const logEl = document.getElementById("log");
    const hintsDisplay = document.getElementById("hintsDisplay");
    const statCombinations = document.getElementById("statCombinations");
    const statLives = document.getElementById("statLives");
    const statChance = document.getElementById("statChance");

    // Criar part√≠culas de fundo
    function createBackgroundParticles() {
      const container = document.getElementById("particles");
      for (let i = 0; i < 30; i++) {
        const particle = document.createElement("div");
        particle.className = "particle";
        particle.style.left = Math.random() * 100 + "%";
        particle.style.animationDelay = Math.random() * 15 + "s";
        particle.style.animationDuration = (10 + Math.random() * 10) + "s";
        container.appendChild(particle);
      }
    }

    function shuffle(arr) {
      return [...arr].sort(() => Math.random() - 0.5);
    }

    function getRandomMessage(category) {
      const msgs = MESSAGES[category];
      return msgs[Math.floor(Math.random() * msgs.length)];
    }

    function showMessage(category, duration = 2000) {
      msgEl.textContent = getRandomMessage(category);
      msgEl.className = "motivational-msg " + category;
      
      if (category === "excellent" || category === "good") {
        msgEl.style.animation = "none";
        setTimeout(() => {
          msgEl.style.animation = "msg-pop 0.5s ease";
        }, 10);
      }
    }

    function levelConfig() {
      // Progress√£o suave: come√ßa com 3 slots, aumenta gradualmente
      // N√≠veis 1-2: 3 slots (6 permuta√ß√µes)
      // N√≠veis 3-5: 4 slots (24 permuta√ß√µes)
      // N√≠veis 6-9: 5 slots (120 permuta√ß√µes)
      // N√≠veis 10+: 6-8 slots
      let size;
      if (level <= 2) size = 3;
      else if (level <= 5) size = 4;
      else if (level <= 9) size = 5;
      else size = Math.min(3 + Math.floor((level - 1) / 3), 8);
      
      // Calcula vidas baseado nas permuta√ß√µes poss√≠veis
      const calculatedLives = calculateLives(size);
      
      // Adiciona b√¥nus de vidas em n√≠veis mais altos para n√£o ficar imposs√≠vel
      const bonusLives = Math.floor((level - 1) / 5); // A cada 5 n√≠veis, +1 vida base
      
      return { 
        size, 
        lives: calculatedLives + bonusLives,
        hints: getHints(level, size)
      };
    }

    function updateProgress(hits) {
      const { size } = levelConfig();
      const progress = (hits / size) * 100;
      progressFill.style.width = progress + "%";
      progressText.textContent = Math.round(progress) + "%";
    }

    function updateLives() {
      // Limpa o container
      livesContainer.innerHTML = "";
      
      // Adiciona cora√ß√µes baseado nas vidas atuais e m√°ximas
      for (let i = 0; i < maxLives; i++) {
        const heart = document.createElement("span");
        heart.className = "heart";
        heart.textContent = "‚ù§Ô∏è";
        
        if (i >= lives) {
          heart.classList.add("lost");
        }
        
        livesContainer.appendChild(heart);
      }
      
      // Mostra contador num√©rico se tiver muitas vidas
      if (maxLives > 5) {
        const counter = document.createElement("span");
        counter.style.cssText = "font-family: 'Orbitron', sans-serif; font-weight: 700; color: var(--danger); margin-left: 8px;";
        counter.textContent = `${lives}/${maxLives}`;
        livesContainer.appendChild(counter);
      }
    }

    function calculateStars() {
      const errors = attempts.filter(a => a < secret.length).length;
      if (errors === 0) return 3;
      if (errors <= 2) return 2;
      return 1;
    }

    function updatePerformanceStars() {
      const stars = calculateStars();
      const starElements = performanceStars.querySelectorAll(".star");
      
      starElements.forEach((star, i) => {
        if (i < stars) {
          setTimeout(() => star.classList.add("earned"), i * 200);
        } else {
          star.classList.remove("earned");
        }
      });

      if (stars === 3) {
        performanceText.textContent = "Perfeito! Sem erros! üèÜ";
      } else if (stars === 2) {
        performanceText.textContent = "Bom trabalho! Poucos erros! üëç";
      } else {
        performanceText.textContent = "Continue praticando! üí™";
      }
    }

    function createParticleEffect(x, y, color, count = 8) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement("div");
        particle.className = "particle-effect";
        particle.style.left = x + "px";
        particle.style.top = y + "px";
        particle.style.background = color;
        
        const angle = (Math.PI * 2 * i) / count;
        const velocity = 50 + Math.random() * 50;
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        
        particle.style.animation = `particle-fly 0.6s ease-out forwards`;
        particle.style.setProperty("--tx", tx + "px");
        particle.style.setProperty("--ty", ty + "px");
        
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 600);
      }
    }

    // Adicionar keyframes din√¢micos
    const style = document.createElement("style");
    style.textContent = `
      @keyframes particle-fly {
        0% { transform: translate(0, 0) scale(1); opacity: 1; }
        100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    function startLevel() {
      const { size, lives: calculatedLives, hints } = levelConfig();
      gameActive = true;
      attempts = [];
      logRound = 1;
      hintsUsed = 0;
      revealedPositions.clear();
      
      // Carregar progresso salvo apenas se n√£o houver reset recente
      const resetTimestamp = localStorage.getItem('sequenceBreaker_reset');
      const hasRecentReset = resetTimestamp && (Date.now() - parseInt(resetTimestamp)) < 5000; // 5 segundos
      
      if (level === 1 && score === 0 && !hasRecentReset) {
        loadGame();
      } else if (hasRecentReset) {
        // Remove a flag de reset ap√≥s usar
        localStorage.removeItem('sequenceBreaker_reset');
      }
      
      // Atualiza vidas com o c√°lculo matem√°tico
      lives = calculatedLives;
      maxLives = calculatedLives;
      updateLives();

      levelEl.textContent = level;
      scoreEl.textContent = score;
      comboEl.textContent = "x" + (combo + 1);
      logEl.innerHTML = "";
      updateProgress(0);
      showMessage("start");
      
      // Atualizar display de estat√≠sticas
      document.getElementById("highScoreDisplay").textContent = highScore;
      document.getElementById("gamesPlayedDisplay").textContent = gamesPlayed;
      const saved = localStorage.getItem('sequenceBreaker');
      if (saved) {
        const data = JSON.parse(saved);
        if (data.lastPlayed) {
          const date = new Date(data.lastPlayed);
          document.getElementById("lastPlayedDisplay").textContent = date.toLocaleDateString('pt-BR');
        }
      }
      
      // Reset performance stars
      performanceStars.querySelectorAll(".star").forEach(s => s.classList.remove("earned"));
      const permutations = factorial(size);
      performanceText.textContent = `${size} cores = ${permutations} combina√ß√µes`;
      
      // Atualiza estat√≠sticas
      hintsDisplay.textContent = hints;
      statCombinations.textContent = permutations;
      statLives.textContent = lives;
      const chance = Math.min(100, Math.round((lives / permutations) * 100));
      statChance.textContent = chance + "%";

      secret = shuffle(COLORS).slice(0, size);
      
      // Embaralha o board mas garante que n√£o √© a solu√ß√£o
      do {
        boardState = shuffle(secret);
      } while (boardState.every((c, i) => c.name === secret[i].name));
      
      selected = [];

      renderBoard();
      
      // Mostrar informa√ß√£o sobre dicas dispon√≠veis
      if (hints > 0) {
        setTimeout(() => {
          showMessage("good");
          msgEl.textContent = `üí° Voc√™ tem ${hints} dicas dispon√≠veis!`;
        }, 2000);
      }
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      
      const shapeContainer = document.createElement("div");
      shapeContainer.className = "shape-container";
      
      const numSlots = boardState.length;
      const radius = 120; // Raio do c√≠rculo circunscrito
      const centerX = 150; // Centro do container (300px / 2)
      const centerY = 150;
      
      // Calcular posi√ß√µes para forma geom√©trica regular
      const positions = calculatePolygonPositions(numSlots, radius, centerX, centerY);
      
      // Criar conectores primeiro (para ficarem atr√°s dos blocos)
      for (let i = 0; i < numSlots; i++) {
        const nextIndex = (i + 1) % numSlots;
        const connector = document.createElement("div");
        connector.className = "connector";
        connector.id = `connector-${i}`;
        
        const pos1 = positions[i];
        const pos2 = positions[nextIndex];
        const angle = Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x);
        const distance = Math.sqrt(Math.pow(pos2.x - pos1.x, 2) + Math.pow(pos2.y - pos1.y, 2));
        
        connector.style.left = (pos1.x + 35) + "px"; // +35 √© metade do tamanho do bloco
        connector.style.top = (pos1.y + 35) + "px";
        connector.style.width = distance + "px";
        connector.style.transform = `rotate(${angle}rad)`;
        
        shapeContainer.appendChild(connector);
      }
      
      // Criar blocos nas posi√ß√µes calculadas
      boardState.forEach((color, index) => {
        const wrapper = document.createElement("div");
        wrapper.className = "slot-wrapper";
        wrapper.style.left = positions[index].x + "px";
        wrapper.style.top = positions[index].y + "px";
        wrapper.dataset.index = index;
        
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.style.backgroundColor = color.value;
        slot.style.backgroundImage = color.pattern;
        slot.dataset.index = index;
        slot.dataset.color = color.name.toLowerCase();
        
        // Adicionar s√≠mbolo para acessibilidade
        const symbol = document.createElement("span");
        symbol.className = "slot-symbol";
        symbol.textContent = color.symbol;
        symbol.style.cssText = `
          position: absolute;
          font-size: 1.8rem;
          font-weight: 900;
          color: rgba(255,255,255,0.9);
          text-shadow: 0 2px 4px rgba(0,0,0,0.5);
          pointer-events: none;
          z-index: 2;
        `;
        slot.appendChild(symbol);
        
        wrapper.appendChild(slot);
        wrapper.onclick = () => selectSlot(index, wrapper);
        shapeContainer.appendChild(wrapper);
      });
      
      boardEl.appendChild(shapeContainer);
    }

    // Calcular posi√ß√µes para pol√≠gono regular
    function calculatePolygonPositions(n, radius, centerX, centerY) {
      const positions = [];
      const offsetAngle = -Math.PI / 2; // Come√ßar do topo (-90 graus)
      
      for (let i = 0; i < n; i++) {
        const angle = offsetAngle + (i * 2 * Math.PI / n);
        const x = centerX + radius * Math.cos(angle) - 35; // -35 para centralizar o bloco
        const y = centerY + radius * Math.sin(angle) - 35;
        positions.push({ x, y });
      }
      
      return positions;
    }

    function selectSlot(index, wrapper) {
      if (!gameActive || selected.length === 2 || isSwapping) return;
      if (selected.find(s => s.index === index)) return;

      const slot = wrapper.querySelector('.slot');
      selected.push({ index, wrapper, slot });
      slot.classList.add("selected");
      wrapper.style.zIndex = "10";
      
      // Destacar conector
      const connector = document.getElementById(`connector-${index}`);
      if (connector) connector.classList.add("active");
      
      if (selected.length === 1) {
        showMessage("first");
      }

      if (selected.length === 2) {
        showMessage("swap");
        setTimeout(swapSelected, 300);
      }
    }

    function swapSelected() {
      if (isSwapping) return;
      isSwapping = true;
      
      const [a, b] = selected;
      const wrapperA = a.wrapper;
      const wrapperB = b.wrapper;
      const slotA = a.slot;
      const slotB = b.slot;

      // Pegar posi√ß√µes atuais dos wrappers
      const posA = {
        x: parseFloat(wrapperA.style.left),
        y: parseFloat(wrapperA.style.top)
      };
      const posB = {
        x: parseFloat(wrapperB.style.left),
        y: parseFloat(wrapperB.style.top)
      };

      const deltaX = posB.x - posA.x;
      const deltaY = posB.y - posA.y;

      slotA.classList.add("animating");
      slotB.classList.add("animating");

      // Anima√ß√£o de troca usando transform
      slotA.style.transition = "transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)";
      slotB.style.transition = "transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)";

      slotA.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.1) rotate(360deg)`;
      slotB.style.transform = `translate(${-deltaX}px, ${-deltaY}px) scale(1.1) rotate(-360deg)`;

      // Criar part√≠culas nos slots
      const rectA = slotA.getBoundingClientRect();
      const rectB = slotB.getBoundingClientRect();
      createParticleEffect(rectA.left + 35, rectA.top + 35, boardState[a.index].value);
      createParticleEffect(rectB.left + 35, rectB.top + 35, boardState[b.index].value);

      setTimeout(() => {
        // Trocar no estado do jogo
        [boardState[a.index], boardState[b.index]] =
          [boardState[b.index], boardState[a.index]];

        // Resetar estilos
        selected.forEach(s => {
          s.slot.classList.remove("selected", "animating");
          s.slot.style.transform = "";
          s.slot.style.transition = "";
          s.wrapper.style.zIndex = "";
        });
        
        // Remover destaque dos conectores
        document.querySelectorAll('.connector.active').forEach(c => c.classList.remove('active'));
        
        // Limpa revealedPositions para posi√ß√µes que foram trocadas
        revealedPositions.delete(a.index);
        revealedPositions.delete(b.index);
        
        selected = [];
        isSwapping = false;
        renderBoard();
      }, 500);
    }

    // Usar uma dica - revela visualmente uma posi√ß√£o correta (mas n√£o resolve automaticamente)
    function useHint() {
      const { hints } = levelConfig();
      if (hintsUsed >= hints) {
        showMessage("warning");
        msgEl.textContent = "Sem dicas dispon√≠veis!";
        return;
      }
      
      // Encontra posi√ß√µes ainda n√£o reveladas e n√£o corretas
      const availablePositions = [];
      for (let i = 0; i < secret.length; i++) {
        if (!revealedPositions.has(i) && boardState[i].name !== secret[i].name) {
          availablePositions.push(i);
        }
      }
      
      if (availablePositions.length === 0) {
        showMessage("good");
        msgEl.textContent = "Todas as posi√ß√µes j√° est√£o corretas!";
        return;
      }
      
      // Escolhe uma posi√ß√£o aleat√≥ria para revelar
      const posToReveal = availablePositions[Math.floor(Math.random() * availablePositions.length)];
      const correctColor = secret[posToReveal];
      
      // Encontra onde est√° a cor correta atualmente
      const currentColorIndex = boardState.findIndex(c => c.name === correctColor.name);
      
      // Apenas mostra visualmente a dica - N√ÉO faz a troca automaticamente
      revealedPositions.add(posToReveal);
      hintsUsed++;
      
      // Atualiza display de dicas
      const { hints } = levelConfig();
      hintsDisplay.textContent = hints - hintsUsed;
      
      // Feedback visual - destaca a posi√ß√£o que precisa da cor correta
      const slots = document.querySelectorAll(".slot-wrapper .slot");
      const targetSlot = slots[posToReveal];
      const sourceSlot = slots[currentColorIndex];
      
      // Destaca a posi√ß√£o alvo com amarelo (indica onde a cor deve ir)
      targetSlot.classList.add("hint-target");
      targetSlot.style.boxShadow = "0 0 30px rgba(255, 255, 0, 0.8), 0 0 60px rgba(255, 255, 0, 0.4)";
      targetSlot.style.animation = "pulse-hint 1s ease-in-out infinite alternate";
      
      // Destaca a posi√ß√£o onde a cor correta est√° atualmente
      sourceSlot.style.boxShadow = "0 0 30px rgba(0, 255, 136, 0.8), 0 0 60px rgba(0, 255, 136, 0.4)";
      sourceSlot.style.animation = "pulse-hint 1s ease-in-out infinite alternate";
      
      // Cria seta indicando a troca sugerida
      showHintArrow(posToReveal, currentColorIndex);
      
      // Destacar conectores
      const connector1 = document.getElementById(`connector-${posToReveal}`);
      const connector2 = document.getElementById(`connector-${currentColorIndex}`);
      if (connector1) {
        connector1.style.background = "rgba(255, 255, 0, 0.8)";
        connector1.style.opacity = "1";
      }
      if (connector2) {
        connector2.style.background = "rgba(0, 255, 136, 0.8)";
        connector2.style.opacity = "1";
      }
      
      showMessage("good");
      msgEl.textContent = `üí° Dica: A cor ${correctColor.symbol} deve ir na posi√ß√£o ${posToReveal + 1}! ${hints - hintsUsed} restantes`;
      
      // Remove o destaque visual ap√≥s 3 segundos
      setTimeout(() => {
        targetSlot.style.boxShadow = "";
        targetSlot.style.animation = "";
        targetSlot.classList.remove("hint-target");
        sourceSlot.style.boxShadow = "";
        sourceSlot.style.animation = "";
        if (connector1) {
          connector1.style.background = "";
          connector1.style.opacity = "";
        }
        if (connector2) {
          connector2.style.background = "";
          connector2.style.opacity = "";
        }
        removeHintArrow();
      }, 3000);
    }
    
    // Mostra uma seta indicando a troca sugerida
    function showHintArrow(targetIndex, sourceIndex) {
      // Remove seta anterior se existir
      removeHintArrow();
      
      const slots = document.querySelectorAll(".slot-wrapper");
      const targetSlot = slots[targetIndex];
      const sourceSlot = slots[sourceIndex];
      
      const targetRect = targetSlot.getBoundingClientRect();
      const sourceRect = sourceSlot.getBoundingClientRect();
      
      const arrow = document.createElement("div");
      arrow.id = "hint-arrow";
      arrow.style.cssText = `
        position: fixed;
        width: 60px;
        height: 4px;
        background: linear-gradient(90deg, #00ff88, #ffff00);
        z-index: 1000;
        pointer-events: none;
        box-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
      `;
      
      // Calcula posi√ß√£o e √¢ngulo da seta
      const targetX = targetRect.left + targetRect.width / 2;
      const targetY = targetRect.top + targetRect.height / 2;
      const sourceX = sourceRect.left + sourceRect.width / 2;
      const sourceY = sourceRect.top + sourceRect.height / 2;
      
      const angle = Math.atan2(targetY - sourceY, targetX - sourceX);
      const distance = Math.sqrt(Math.pow(targetX - sourceX, 2) + Math.pow(targetY - sourceY, 2));
      
      arrow.style.width = distance + "px";
      arrow.style.left = sourceX + "px";
      arrow.style.top = sourceY + "px";
      arrow.style.transform = `rotate(${angle}rad)`;
      arrow.style.transformOrigin = "0 50%";
      
      // Adiciona ponta da seta
      const arrowHead = document.createElement("div");
      arrowHead.style.cssText = `
        position: absolute;
        right: -10px;
        top: -8px;
        width: 0;
        height: 0;
        border-left: 20px solid #ffff00;
        border-top: 10px solid transparent;
        border-bottom: 10px solid transparent;
        filter: drop-shadow(0 0 5px rgba(255, 255, 0, 0.8));
      `;
      arrow.appendChild(arrowHead);
      
      document.body.appendChild(arrow);
    }
    
    // Remove a seta de dica
    function removeHintArrow() {
      const existingArrow = document.getElementById("hint-arrow");
      if (existingArrow) {
        existingArrow.remove();
      }
    }

    function checkBoard() {
      if (!gameActive) return;

      let hits = 0;
      const wrappers = document.querySelectorAll(".slot-wrapper");
      const slots = document.querySelectorAll(".slot-wrapper .slot");
      const wrongPositions = [];

      boardState.forEach((color, i) => {
        // Comparar pelo nome da cor ao inv√©s de refer√™ncia do objeto
        if (color.name === secret[i].name) {
          hits++;
          slots[i].classList.add("correct");
          // Destacar conector tamb√©m
          const connector = document.getElementById(`connector-${i}`);
          if (connector) {
            connector.style.background = "var(--success)";
            connector.style.opacity = "1";
            connector.style.boxShadow = "0 0 15px var(--success)";
          }
          // Part√≠culas nas pe√ßas corretas
          const rect = slots[i].getBoundingClientRect();
          createParticleEffect(rect.left + 35, rect.top + 35, color.value, 12);
        } else {
          slots[i].classList.add("wrong");
          wrongPositions.push(i);
          // Conector em vermelho para errados
          const connector = document.getElementById(`connector-${i}`);
          if (connector) {
            connector.style.background = "var(--danger)";
            connector.style.opacity = "0.6";
          }
        }
      });

      attempts.push(hits);
      updateProgress(hits);

      // Sistema de combo
      if (hits === secret.length) {
        combo++;
        if (combo > maxCombo) maxCombo = combo;
        
        // B√¥nus de pontua√ß√£o escalonado por dificuldade
        const basePoints = hits * 100;
        const comboBonus = combo * 50;
        const perfectBonus = attempts.length === 1 ? 500 : 0;
        const difficultyBonus = (secret.length - 3) * 50; // Bonus por n√≠vel dif√≠cil
        const hintBonus = (getHints(level, secret.length) - hintsUsed) * 100; // Bonus por n√£o usar dicas
        const roundPoints = basePoints + comboBonus + perfectBonus + difficultyBonus + hintBonus;
        
        score += roundPoints;
        scoreEl.textContent = score;
        comboEl.textContent = "x" + (combo + 1);
        comboEl.classList.add("combo");
        setTimeout(() => comboEl.classList.remove("combo"), 500);
        
        showMessage("excellent");
        
        // Atualizar high score se necess√°rio
        if (score > highScore) {
          highScore = score;
          document.getElementById("highScoreDisplay").textContent = highScore;
        }
        
        // Salvar progresso
        saveGame();
        
        setTimeout(() => {
          updatePerformanceStars();
          showVictory();
        }, 800);
        
      } else {
        combo = 0;
        comboEl.textContent = "x1";
        lives--;
        updateLives();
        
        // Mostra quais posi√ß√µes est√£o erradas com n√∫meros
        if (wrongPositions.length > 0) {
          showMessage("bad");
          const accuracy = Math.round((hits / secret.length) * 100);
          msgEl.textContent = `${hits}/${secret.length} corretos (${accuracy}%) - ${lives} vidas restantes`;
        }

        if (lives === 0) {
          setTimeout(showGameOver, 1500);
        } else if (lives <= Math.ceil(maxLives * 0.3)) {
          showMessage("danger");
          // Oferece dica autom√°tica quando est√° com poucas vidas
          const { hints } = levelConfig();
          if (hintsUsed < hints) {
            setTimeout(() => {
              msgEl.textContent = "üí° Pressione 'D' para usar uma dica!";
            }, 2000);
          }
        }

        // Log detalhado
        const logEntry = document.createElement("div");
        const accuracy = Math.round((hits / secret.length) * 100);
        logEntry.className = "log-entry " + (hits === secret.length ? "perfect" : hits === 0 ? "bad" : "");
        logEntry.innerHTML = `
          <span>Tentativa ${logRound}</span>
          <span style="color: ${hits === secret.length ? 'var(--success)' : hits === 0 ? 'var(--danger)' : 'var(--accent)'}">
            ${hits}/${secret.length} (${accuracy}%)
          </span>
        `;
        logEl.insertBefore(logEntry, logEl.firstChild);
        logRound++;

        setTimeout(() => {
          slots.forEach(s => s.classList.remove("correct", "wrong"));
          // Resetar conectores
          document.querySelectorAll('.connector').forEach(c => {
            c.style.background = "";
            c.style.opacity = "";
            c.style.boxShadow = "";
          });
        }, 1500);
      }
    }

    function showVictory() {
      const overlay = document.getElementById("victoryOverlay");
      const stars = calculateStars();
      
      document.getElementById("summaryScore").textContent = score;
      document.getElementById("summaryCombo").textContent = "x" + maxCombo;
      document.getElementById("summaryAccuracy").textContent = 
        Math.round((attempts.filter(a => a === secret.length).length / attempts.length) * 100) || 100 + "%";
      
      // Mostrar estrelas
      const victoryStars = document.getElementById("victoryStars").querySelectorAll(".star");
      victoryStars.forEach((star, i) => {
        star.classList.remove("earned");
        if (i < stars) {
          setTimeout(() => star.classList.add("earned"), 300 + i * 200);
        }
      });
      
      overlay.classList.add("active");
      createConfetti();
    }

    function showGameOver() {
      gameActive = false;
      gamesPlayed++;
      
      // Salvar progresso ao perder
      saveGame();
      
      const overlay = document.getElementById("gameoverOverlay");
      const solutionBoard = document.getElementById("solutionBoard");

      solutionBoard.innerHTML = "";
      
      // Criar container para a solu√ß√£o em formato geom√©trico
      const solutionContainer = document.createElement("div");
      solutionContainer.className = "solution-shape-container";
      solutionContainer.style.cssText = `
        position: relative;
        width: 250px;
        height: 250px;
        margin: 0 auto;
      `;
      
      const numSlots = secret.length;
      const radius = 100;
      const centerX = 125;
      const centerY = 125;
      const positions = calculatePolygonPositions(numSlots, radius, centerX, centerY);
      
      secret.forEach((color, index) => {
        const wrapper = document.createElement("div");
        wrapper.style.cssText = `
          position: absolute;
          width: 50px;
          height: 50px;
          left: ${positions[index].x + 10}px;
          top: ${positions[index].y + 10}px;
          animation: solution-pop 0.5s ease-out backwards;
          animation-delay: ${index * 0.1}s;
        `;
        
        const slot = document.createElement("div");
        slot.className = "solution-slot";
        slot.style.background = color.value;
        slot.style.width = "100%";
        slot.style.height = "100%";
        slot.style.position = "relative";
        
        // Adicionar s√≠mbolo tamb√©m na solu√ß√£o
        const symbol = document.createElement("span");
        symbol.className = "slot-symbol";
        symbol.textContent = color.symbol;
        symbol.style.cssText = `
          position: absolute;
          font-size: 1.5rem;
          font-weight: 900;
          color: rgba(255,255,255,0.9);
          text-shadow: 0 2px 4px rgba(0,0,0,0.5);
          pointer-events: none;
          z-index: 2;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
        `;
        slot.appendChild(symbol);
        
        wrapper.appendChild(slot);
        solutionContainer.appendChild(wrapper);
      });
      
      solutionBoard.appendChild(solutionContainer);

      overlay.classList.add("active");
    }

    function createConfetti() {
      const colors = ["#00d9ff", "#b829dd", "#ffaa00", "#00ff88", "#ff3366", "#ff00aa"];
      for (let i = 0; i < 60; i++) {
        setTimeout(() => {
          const confetti = document.createElement("div");
          confetti.className = "confetti";
          confetti.style.left = Math.random() * 100 + "vw";
          confetti.style.top = "-20px";
          confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.animation = `confetti-fall ${2 + Math.random() * 2}s ease-out forwards`;
          confetti.style.borderRadius = Math.random() > 0.5 ? "50%" : "0";
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          document.body.appendChild(confetti);
          setTimeout(() => confetti.remove(), 4000);
        }, i * 30);
      }
    }

    // Adicionar keyframes do confetti
    const confettiStyle = document.createElement("style");
    confettiStyle.textContent = `
      @keyframes confetti-fall {
        0% { transform: translateY(0) rotate(0deg); opacity: 1; }
        100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
      }
    `;
    document.head.appendChild(confettiStyle);

    function nextLevel() {
      document.getElementById("victoryOverlay").classList.remove("active");
      level++;
      startLevel();
    }

    function restartGame() {
      document.getElementById("gameoverOverlay").classList.remove("active");
      level = 1;
      startLevel();
    }

    // Fun√ß√µes do modal de regras
    function showRules() {
      document.getElementById("rulesOverlay").classList.add("active");
    }

    function hideRules() {
      document.getElementById("rulesOverlay").classList.remove("active");
    }

    // Tecla 'D' para usar dica
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'd' && gameActive) {
        useHint();
      }
    });

    document.getElementById("checkBtn").onclick = checkBoard;
    document.getElementById("hintBtn").onclick = useHint;
    document.getElementById("resetBtn").onclick = () => {
      level = 1;
      startLevel();
    };
    document.getElementById("helpBtn").onclick = showRules;

    // Tecla '?' para mostrar regras
    document.addEventListener('keydown', (e) => {
      if (e.key === '?') {
        showRules();
      } else if (e.key === 'Escape') {
        hideRules();
      }
    });

    createBackgroundParticles();
    startLevel();
  </script>
</body>
</html>
